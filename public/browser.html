<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <meta
      name="description"
      content="Securely split a secret into shares or recover the original secret from shares."
    />
    <meta
      name="keywords"
      content="shamir, secret sharing, split, recover, secret, shares"
    />
    <meta name="author" content="SmartLedger & Codenlighten" />
    <meta name="robots" content="index, follow" />
    <meta name="revisit-after" content="3 days" />
    <meta name="language" content="English" />

    <meta
      property="og:title"
      content="SecretSlices.com Shamir Secret Sharing"
    />
    <meta
      property="og:description"
      content="Securely split a secret into shares or recover the original secret from shares."
    />
    <!-- favicon -->
    <link rel="icon" href="secretslice.webp" type="image/x-icon" />
    <meta
      property="og:image"
      content="https://secretslices.com/secretslice.webp"
    />
    <meta property="og:url" content="https://secretslices.com" />
    <meta property="og:site_name" content="SecretSlices.com" />
    <meta property="og:type" content="website" />
    <meta property="og:locale" content="en_US" />

    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@smart_ledger" />
    <meta name="twitter:creator" content="@codenlighten1" />
    <meta
      name="twitter:title"
      content="SecretSlices.com Shamir Secret Sharing"
    />
    <meta
      name="twitter:description"
      content="Securely split a secret into shares or recover the original secret from shares."
    />
    <meta
      name="twitter:image"
      content="https://secretslices.com/secretslice.webp"
    />

    <title>SecretSlices.com - Shamir Secret Sharing</title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/milligram/dist/milligram.min.css"
    />
    <!-- bsv unpkg -->
    <script src="https://unpkg.com/bsv@1.5"></script>
    <script src="https://cdn.jsdelivr.net/npm/bsv@1.5.0/bsv-message.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bsv@1.5.0/bsv-mnemonic.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bsv@1.5.0/bsv-ecies.min.js"></script>
    <style>
      body {
        margin: 0 auto;
        max-width: 800px;
        padding: 20px;
      }
      #split-result,
      #recover-result {
        background-color: #f0f0f0;
        border-radius: 4px;
        padding: 10px;
        margin-top: 20px;
        overflow-y: auto;
      }
      textarea {
        min-height: 100px;
      }
      .clickable-part {
        cursor: pointer;
        margin-bottom: 5px;
        display: inline-block;
        background: #e1e1e1;
        border-radius: 4px;
        padding: 5px;
        font-size: 90%;
      }
      .clickable-part:hover {
        background: #d1d1d1;
      }
      /* checkbox and label on same line*/
      input[type="checkbox"] {
        display: none;
      }
      input[type="checkbox"] + label {
        display: inline-block;
        cursor: pointer;
        padding: 5px 10px;
        border: 1px solid #ccc;
        border-radius: 4px;
      }
      input[type="checkbox"]:checked + label {
        background-color: #007bff;
        color: #fff;
      }

      /* encrypt and decrypt button */

      #encrypt,
      #decrypt :hover {
        background-color: #007bff;
        color: #fff;
      }

      footer {
        margin-top: 20px;
        text-align: center;
      }
      #recovered {
        background-color: #f0f0f0;
        border-radius: 4px;
        padding: 10px;
        margin: 20px;
        overflow-y: auto;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Secret Slices</h1>
      <p>
        Securely split a secret into shares or recover the original secret from
        shares.
      </p>
    </header>
    <main>
      <section>
        <h2>Split Secret</h2>
        <form id="split-form">
          <fieldset>
            <label for="secret">Secret Message</label>
            <input
              type="text"
              id="secret"
              name="secret"
              required
              placeholder="Enter secret message"
            />
            <!-- checkbox change to private key -->
            <input
              type="checkbox"
              id="privateKey"
              name="privateKey"
              value="privateKey"
            />
            <label id="changeLabel" for="privateKey"
              >Change to a Private Key</label
            >
            <!-- checkbox to check for encrypt message -->
            <input
              type="checkbox"
              id="encrypt"
              name="encrypt"
              value="encrypt"
            />
            <label for="encrypt">Encrypt Secret</label>
            <label for="threshold"
              >Threshold (Minimum shares to recover secret)</label
            >
            <input
              type="number"
              id="threshold"
              name="threshold"
              required
              placeholder="Enter threshold"
            />
            <label for="shares">Number of Shares</label>
            <input
              type="number"
              id="shares"
              name="shares"
              required
              placeholder="Enter number of shares"
            />

            <button type="submit" class="button-primary">Split Secret</button>
          </fieldset>
        </form>
        <div id="split-result"></div>
      </section>
      <section>
        <h2>Recover Secret</h2>
        <form id="recover-form">
          <fieldset>
            <label for="shares2"
              >Click on key slices above or manually enter Shares (as JSON
              array)</label
            >
            <textarea
              id="shares2"
              name="shares"
              required
              placeholder='Format: [{"part":"1","value":"..."}, ...]'
            ></textarea>
            <button type="submit" class="button-primary">Recover Secret</button>
            <!-- check box to decrypt -->
            <input
              type="checkbox"
              id="decrypt"
              name="decrypt"
              value="decrypt"
            />
            <label for="decrypt">Decrypt Secret</label>
          </fieldset>
        </form>

        <div id="recover-result"></div>
      </section>
      <section class="section" id="help-page">
        <a href="/help.html">Help & Guide</a>
      </section>
      <footer>
        <p>
          &copy; 2024 SecretSlices.com, a project by
          <a href="https://smartledger.solutions" target="_blank"
            >SmartLedger</a
          >
          &
          <a href="https://twitter.com/codenlighten1" target="_blank"
            >Codenlighten</a
          >
        </p>
      </footer>
    </main>
    <script>
      (function (m, k) {
        function t(b) {
          if (b && ("number" !== typeof b || 0 !== b % 1 || b < g.h || b > g.f))
            throw Error(
              "Number of bits must be an integer between " +
                g.h +
                " and " +
                g.f +
                ", inclusive."
            );
          a.b = g.b;
          a.a = b || g.a;
          a.size = Math.pow(2, a.a);
          a.max = a.size - 1;
          b = [];
          for (var e = [], d = 1, c = g.l[a.a], f = 0; f < a.size; f++)
            (e[f] = d),
              (b[d] = f),
              (d <<= 1),
              d >= a.size && ((d ^= c), (d &= a.max));
          a.c = b;
          a.e = e;
        }
        function u() {
          return a.a &&
            a.size &&
            a.max &&
            a.c &&
            a.e &&
            a.c.length === a.size &&
            a.e.length === a.size
            ? !0
            : !1;
        }
        function z() {
          function b(b, e, a, d) {
            for (var c = "", g = 0, m = e.length - 1; g < m || c.length < b; )
              (c += p(parseInt(e[g], a).toString(2), d)), g++;
            c = c.substr(-b);
            return (c.match(/0/g) || []).length === c.length ? null : c;
          }
          var e, d;
          if (
            "function" === typeof require &&
            (d = require("crypto")) &&
            (e = d.randomBytes)
          )
            return function (a) {
              for (var d = Math.ceil(a / 8), c = null; null === c; )
                c = b(a, e(d).toString("hex"), 16, 4);
              return c;
            };
          if (
            k.crypto &&
            "function" === typeof k.crypto.getRandomValues &&
            "function" === typeof k.Uint32Array
          )
            return (
              (d = k.crypto),
              function (a) {
                for (
                  var e = null, c = new k.Uint32Array(Math.ceil(a / 32));
                  null === e;

                )
                  d.getRandomValues(c), (e = b(a, c, 10, 32));
                return e;
              }
            );
          a.d = !0;
          q();
          var c = Math.pow(2, 32) - 1;
          return function (a) {
            for (var e = Math.ceil(a / 32), d = [], l = null; null === l; ) {
              for (l = 0; l < e; l++) d[l] = Math.floor(Math.random() * c + 1);
              l = b(a, d, 10, 32);
            }
            return l;
          };
        }
        function q() {
          k.console.warn(g.k);
          "function" === typeof k.alert && a.alert && k.alert(g.k);
        }
        function s(b) {
          var e = parseInt(b[0], 36);
          if (e && ("number" !== typeof e || 0 !== e % 1 || e < g.h || e > g.f))
            throw Error(
              "Number of bits must be an integer between " +
                g.h +
                " and " +
                g.f +
                ", inclusive."
            );
          var d = Math.pow(2, e) - 1,
            c = d.toString(a.b).length,
            f = parseInt(b.substr(1, c), a.b);
          if ("number" !== typeof f || 0 !== f % 1 || 1 > f || f > d)
            throw Error(
              "Share id must be an integer between 1 and " +
                a.max +
                ", inclusive."
            );
          b = b.substr(c + 1);
          if (!b.length) throw Error("Invalid share: zero-length share.");
          return { bits: e, id: f, value: b };
        }
        function v(b, e) {
          for (
            var d, c, f = [], n = [], h = "", l, g = 0, m = e.length;
            g < m;
            g++
          ) {
            c = s(e[g]);
            if ("undefined" === typeof d) d = c.bits;
            else if (c.bits !== d)
              throw Error("Mismatched shares: Different bit settings.");
            a.a !== d && t(d);
            a: {
              l = 0;
              for (var k = f.length; l < k; l++)
                if (f[l] === c.id) {
                  l = !0;
                  break a;
                }
              l = !1;
            }
            if (!l) {
              l = f.push(c.id) - 1;
              c = w(x(c.value));
              for (var k = 0, q = c.length; k < q; k++)
                (n[k] = n[k] || []), (n[k][l] = c[k]);
            }
          }
          g = 0;
          for (m = n.length; g < m; g++) h = p(y(b, f, n[g]).toString(2)) + h;
          return 0 === b ? ((l = h.indexOf("1")), r(h.slice(l + 1))) : r(h);
        }
        function y(b, e, d) {
          var c = 0,
            f,
            n,
            h;
          n = 0;
          for (var g = e.length; n < g; n++)
            if (d[n]) {
              f = a.c[d[n]];
              for (h = 0; h < g; h++)
                if (n !== h) {
                  if (b === e[h]) {
                    f = -1;
                    break;
                  }
                  f = (f + a.c[b ^ e[h]] - a.c[e[n] ^ e[h]] + a.max) % a.max;
                }
              c = -1 === f ? c : c ^ a.e[f];
            }
          return c;
        }
        function w(b, e) {
          e && (b = p(b, e));
          for (var d = [], c = b.length; c > a.a; c -= a.a)
            d.push(parseInt(b.slice(c - a.a, c), 2));
          d.push(parseInt(b.slice(0, c), 2));
          return d;
        }
        function p(b, e) {
          e = e || a.a;
          var d = b.length % e;
          return (d ? Array(e - d + 1).join("0") : "") + b;
        }
        function x(b) {
          for (var a = "", d, c = b.length - 1; 0 <= c; c--) {
            d = parseInt(b[c], 16);
            if (isNaN(d)) throw Error("Invalid hex character.");
            a = p(d.toString(2), 4) + a;
          }
          return a;
        }
        function r(b) {
          var a = "",
            d;
          b = p(b, 4);
          for (var c = b.length; 4 <= c; c -= 4) {
            d = parseInt(b.slice(c - 4, c), 2);
            if (isNaN(d)) throw Error("Invalid binary character.");
            a = d.toString(16) + a;
          }
          return a;
        }
        var g = {
            a: 8,
            b: 16,
            h: 3,
            f: 20,
            j: 2,
            g: 6,
            l: [
              null,
              null,
              1,
              3,
              3,
              5,
              3,
              3,
              29,
              17,
              9,
              5,
              83,
              27,
              43,
              3,
              45,
              9,
              39,
              39,
              9,
              5,
              3,
              33,
              27,
              9,
              71,
              39,
              9,
              5,
              83,
            ],
            k: "WARNING:\nA secure random number generator was not found.\nUsing Math.random(), which is NOT cryptographically strong!",
          },
          a = {};
        m.getConfig = function () {
          return { bits: a.a, unsafePRNG: a.d };
        };
        m.init = t;
        m.setRNG = function (b, e) {
          u() || this.init();
          a.d = !1;
          b = b || z();
          if (
            "function" !== typeof b ||
            "string" !== typeof b(a.a) ||
            !parseInt(b(a.a), 2) ||
            b(a.a).length > a.a ||
            b(a.a).length < a.a
          )
            throw Error(
              "Random number generator is invalid. Supply an RNG of the form function(bits){} that returns a string containing 'bits' number of random 1's and 0's."
            );
          a.i = b;
          a.alert = !!e;
          return !!a.d;
        };
        m.random = function (b) {
          "function" !== typeof a.i && this.setRNG();
          if ("number" !== typeof b || 0 !== b % 1 || 2 > b)
            throw Error("Number of bits must be an integer greater than 1.");
          a.d && q();
          return r(a.i(b));
        };
        m.share = function (b, e, d, c, f) {
          u() || this.init();
          "function" !== typeof a.i && this.setRNG();
          c = c || 0;
          if ("string" !== typeof b) throw Error("Secret must be a string.");
          if ("number" !== typeof e || 0 !== e % 1 || 2 > e)
            throw Error(
              "Number of shares must be an integer between 2 and 2^bits-1 (" +
                a.max +
                "), inclusive."
            );
          if (e > a.max)
            throw (
              ((f = Math.ceil(Math.log(e + 1) / Math.LN2)),
              Error(
                "Number of shares must be an integer between 2 and 2^bits-1 (" +
                  a.max +
                  "), inclusive. To create " +
                  e +
                  " shares, use at least " +
                  f +
                  " bits."
              ))
            );
          if ("number" !== typeof d || 0 !== d % 1 || 2 > d)
            throw Error(
              "Threshold number of shares must be an integer between 2 and 2^bits-1 (" +
                a.max +
                "), inclusive."
            );
          if (d > a.max)
            throw (
              ((f = Math.ceil(Math.log(d + 1) / Math.LN2)),
              Error(
                "Threshold number of shares must be an integer between 2 and 2^bits-1 (" +
                  a.max +
                  "), inclusive.  To use a threshold of " +
                  d +
                  ", use at least " +
                  f +
                  " bits."
              ))
            );
          if ("number" !== typeof c || 0 !== c % 1)
            throw Error("Zero-pad length must be an integer greater than 1.");
          a.d && q();
          b = "1" + x(b);
          b = w(b, c);
          c = Array(e);
          for (var g = Array(e), h = 0, l = b.length; h < l; h++)
            for (var m = this._getShares(b[h], e, d), k = 0; k < e; k++)
              (c[k] = c[k] || m[k].x.toString(a.b)),
                (g[k] = p(m[k].y.toString(2)) + (g[k] ? g[k] : ""));
          d = a.max.toString(a.b).length;
          if (f) for (h = 0; h < e; h++) c[h] = r(g[h]);
          else
            for (h = 0; h < e; h++)
              c[h] = a.a.toString(36).toUpperCase() + p(c[h], d) + r(g[h]);
          return c;
        };
        m._getShares = function (b, e, d) {
          var c = [];
          b = [b];
          for (var f = 1; f < d; f++) b[f] = parseInt(a.i(a.a), 2);
          f = 1;
          for (e += 1; f < e; f++) {
            d = a.c[f];
            for (var g = 0, h = b.length - 1; 0 <= h; h--)
              g = 0 === g ? b[h] : a.e[(d + a.c[g]) % a.max] ^ b[h];
            c[f - 1] = { x: f, y: g };
          }
          return c;
        };
        m._processShare = s;
        m.combine = function (b) {
          return v(0, b);
        };
        m.newShare = function (b, e) {
          "string" === typeof b && (b = parseInt(b, a.b));
          var d = s(e[0]),
            d = Math.pow(2, d.bits) - 1;
          if ("number" !== typeof b || 0 !== b % 1 || 1 > b || b > d)
            throw Error(
              "Share id must be an integer between 1 and " +
                a.max +
                ", inclusive."
            );
          return (
            a.a.toString(36).toUpperCase() +
            p(b.toString(a.b), d.toString(a.b).length) +
            v(b, e)
          );
        };
        m._lagrange = y;
        m.str2hex = function (b, a) {
          if ("string" !== typeof b)
            throw Error("Input must be a character string.");
          a = a || g.j;
          if ("number" !== typeof a || 0 !== a % 1 || 1 > a || a > g.g)
            throw Error(
              "Bytes per character must be an integer between 1 and " +
                g.g +
                ", inclusive."
            );
          for (
            var d = 2 * a,
              c = Math.pow(16, d) - 1,
              f = "",
              k,
              h = 0,
              l = b.length;
            h < l;
            h++
          ) {
            k = b[h].charCodeAt();
            if (isNaN(k)) throw Error("Invalid character: " + b[h]);
            if (k > c)
              throw (
                ((d = Math.ceil(Math.log(k + 1) / Math.log(256))),
                Error(
                  "Invalid character code (" +
                    k +
                    "). Maximum allowable is 256^bytes-1 (" +
                    c +
                    "). To convert this character, use at least " +
                    d +
                    " bytes."
                ))
              );
            f = p(k.toString(16), d) + f;
          }
          return f;
        };
        m.hex2str = function (a, e) {
          if ("string" !== typeof a)
            throw Error("Input must be a hexadecimal string.");
          e = e || g.j;
          if ("number" !== typeof e || 0 !== e % 1 || 1 > e || e > g.g)
            throw Error(
              "Bytes per character must be an integer between 1 and " +
                g.g +
                ", inclusive."
            );
          var d = 2 * e,
            c = "";
          a = p(a, d);
          for (var f = 0, k = a.length; f < k; f += d)
            c = String.fromCharCode(parseInt(a.slice(f, f + d), 16)) + c;
          return c;
        };
        m.init();
      })(
        "undefined" !== typeof module && module.exports
          ? module.exports
          : (window.secrets = {}),
        "undefined" !== typeof global ? global : window
      );
    </script>
    <script src="encryption.js"></script>
    <script>
      //clear inputs
      // ondom load

      document.getElementById("secret").value = "";
      document.getElementById("threshold").value = "";
      document.getElementById("shares").value = "";
      document.getElementById("shares2").value = "";
      //uncheck checkbox
      document.getElementById("privateKey").checked = false;
      document.getElementById("encrypt").checked = false;
      document.getElementById("decrypt").checked = false;
      const Buffer = bsv.deps.Buffer;
      const generateKeys = () => {
        const Mnemonic = bsv.Mnemonic;
        const mnemonic = new Mnemonic();
        const fullPath = "m/44'/0'/0'/0/0";
        const xpriv = mnemonic.toHDPrivateKey(); // HD Private Key
        const derivedPriv = xpriv.deriveChild(fullPath); // Derive the private key using the full path
        const priv = derivedPriv.privateKey; // Get the actual private key
        const pub = bsv.PublicKey.fromPrivateKey(priv); // Derive the public key from the private key
        address = bsv.Address.fromPublicKey(pub).toString();
        const jsonString = JSON.stringify({
          address: address,
          privateKey: priv.toString(),
          publicKey: pub.toString(),
          mnemonic: mnemonic.toString(),
          path: fullPath,
        });
        return jsonString;
      };
      const encrypt = (myString, myPassword) => {
        //crypto-js
        const cryptoJS = window.CryptoJS;
        // Encrypt
        const ciphertext = cryptoJS.AES.encrypt(
          myString,
          myPassword
        ).toString();
        return ciphertext;
      };
      //
      const decrypt = (myString, myPassword) => {
        //crypto-js
        const cryptoJS = window.CryptoJS;
        // Decrypt
        const bytes = cryptoJS.AES.decrypt(myString, myPassword);
        const plaintext = bytes.toString(cryptoJS.enc.Utf8);
        return plaintext;
      };
      const keys = generateKeys();
      const mnemonic = JSON.parse(keys).mnemonic;
      // const password = prompt("Enter a password to encrypt your mnemonic");
      // const encryptedMnemonic = encrypt(mnemonic, password);
      // console.log("Encrypted Mnemonic: ", encryptedMnemonic);
      //add to message
      document.getElementById("secret").value = mnemonic;
      //check if checkbox is checked
      async function makeRandomShares(message, threshold, totalShares) {
        // Convert the message to a hex string if necessary
        let hexMessage = Buffer.from(message, "utf8").toString("hex");
        // Split the hex message into shares
        console.log("Hex Message: ", hexMessage);
        let shares = await secrets.share(hexMessage, totalShares, threshold);
        //   const partStrings = Object.entries(parts).map(([part, value]) => ({
        //   part,
        //   value: Array.from(value).toString(),
        // }));
        shares = shares.map((share, i) => {
          return {
            part: i + 1,
            value: share,
          };
        });
        console.log("shares: ", shares);
        return shares;
      }

      function recoverSecret(shares) {
        // Combine the shares to reconstruct the hex message
        let combinedHex = secrets.combine(shares);
        // Convert the hex string back to the original message (utf8)
        let message = Buffer.from(combinedHex, "hex").toString("utf8");
        return message;
      }
      document.getElementById("privateKey").addEventListener("change", () => {
        if (document.getElementById("privateKey").checked) {
          const privateKey = JSON.parse(keys).privateKey;
          document.getElementById("secret").value = privateKey;
          document.getElementById("changeLabel").textContent =
            "Change to a Mnemonic";
          // unchecked checkbox
          document.getElementById("encrypt").checked = false;
        } else {
          const mnemonic = JSON.parse(keys).mnemonic;
          document.getElementById("secret").value = mnemonic;
          document.getElementById("changeLabel").textContent =
            "Change to a Private Key";
          document.getElementById("encrypt").checked = false;
        }
      });
      document
        .getElementById("split-form")
        .addEventListener("submit", async (event) => {
          event.preventDefault();
          const secret = document.getElementById("secret").value;
          let threshold = document.getElementById("threshold").value;
          let shares = document.getElementById("shares").value;
          threshold = parseInt(threshold);
          shares = parseInt(shares);
          console.log(
            "Secret: ",
            secret,
            "Threshold: ",
            threshold,
            "Shares: ",
            shares
          );
          try {
            const data = await makeRandomShares(secret, threshold, shares);
            const resultContainer = document.getElementById("split-result");
            resultContainer.innerHTML = ""; // Clear previous results
            const directions = document.createElement("p");
            directions.textContent =
              "Click on necessary number of parts to add it to the recover form & test recovery, or download all parts.";
            resultContainer.appendChild(directions);
            // Create clickable parts for each split secret
            data.forEach((part, index) => {
              const partElement = document.createElement("div");
              partElement.classList.add("clickable-part");
              partElement.textContent = `Part ${index + 1}-${part.value}`;
              partElement.id = part.value;
              partElement.onclick = () => addPartToRecover(part);
              resultContainer.appendChild(partElement);
            });
            //download each part as a file when download button is clicked
            const downloadButton = document.createElement("button");
            downloadButton.textContent = "Download All Parts";
            downloadButton.onclick = () => {
              data.forEach((part, index) => {
                const blob = new Blob([JSON.stringify(part)], {
                  type: "application/json",
                });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = `part-${index + 1}.json`;
                a.click();
                URL.revokeObjectURL(url);
              });
            };
            resultContainer.appendChild(downloadButton);
          } catch (error) {
            console.log("Error: ", error);
            document.getElementById("split-result").textContent =
              "Error splitting the secret. Please check your input.";
          }
        });
      const recoverArray = [];
      function addPartToRecover(part) {
        recoverArray.push(part);
        console.log("Recover Array: ", recoverArray);
        document.getElementById("shares2").value = JSON.stringify(recoverArray);
      }

      document
        .getElementById("recover-form")
        .addEventListener("submit", async (event) => {
          event.preventDefault();
          const totalShares = [];
          let shares = document.getElementById("shares2").value;
          shares = JSON.parse(shares);
          for (let i = 0; i < shares.length; i++) {
            console.log("Shares: ", shares[i]);
            totalShares.push(shares[i].value);
          }
          try {
            const recoveredSecret = recoverSecret(totalShares);
            console.log("Shares: ", shares);
            const resultContainer = document.getElementById("recover-result");
            resultContainer.innerHTML = ""; // Clear previous results
            const recoveredElement = document.createElement("p");
            recoveredElement.id = "recovered";
            recoveredElement.textContent = recoveredSecret;
            resultContainer.appendChild(recoveredElement);
            //enable checkbox
            document.getElementById("decrypt").disabled = false;
          } catch (error) {
            console.log("Error: ", error);
            document.getElementById("recover-result").textContent =
              "Error recovering the secret. Please check your input.";
          }
        });

      //check if checkbox is checked
      document.getElementById("encrypt").addEventListener("change", () => {
        if (document.getElementById("encrypt").checked) {
          const secret = document.getElementById("secret").value;
          const password = prompt("Enter a password to encrypt your secret");
          const encryptedSecret = encrypt(secret, password);
          document.getElementById("secret").value = encryptedSecret;
        } else {
          const secret = document.getElementById("secret").value;
          const password = prompt("Enter a password to decrypt your secret");
          const decryptedSecret = decrypt(secret, password);
          document.getElementById("secret").value = decryptedSecret;
        }
      });

      //check if checkbox is checked
      document.getElementById("decrypt").addEventListener("change", () => {
        const recoveredSecret =
          document.getElementById("recovered").textContent;
        console.log("Recovered Secret: ", recoveredSecret);
        const password = prompt("Enter a password to decrypt your secret");
        const decryptedSecret = decrypt(recoveredSecret, password);
        document.getElementById(
          "recover-result"
        ).innerHTML = `<p id="recovered">${decryptedSecret}</p>`;
        //disable checkbox
        document.getElementById("decrypt").disabled = true;
      });
    </script>
  </body>
</html>
